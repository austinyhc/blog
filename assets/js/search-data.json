{
  
    
        "post0": {
            "title": "Cassava Leaf Disease Classification - EDA",
            "content": "import numpy as np import pandas as pd import seaborn as sns from glob import glob import albumentations as A from pylab import rcParams import matplotlib.pyplot as plt import plotly.graph_objects as go import os, gc, cv2, random, warnings, math, sys, json, pprint from pathlib import Path Path.ls = lambda x: list(x.iterdir()) import altair as alt # sklearn from sklearn.utils import class_weight from sklearn.model_selection import StratifiedKFold from sklearn.metrics import accuracy_score, balanced_accuracy_score # tf import tensorflow as tf from tensorflow.keras import backend as K os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;3&#39; warnings.simplefilter(&#39;ignore&#39;) . # helper function to plot sample def plot_imgs(dataset_show, iters): rcParams[&#39;figure.figsize&#39;] = 20,10 for i in range(iters): f, ax = plt.subplots(1,5) for p in range(5): idx = np.random.randint(0, len(dataset_show)) img, label = dataset_show[idx] ax[p].grid(False) ax[p].imshow(img[0]) ax[p].set_title(idx) plt.show() def visualize(path, n_images, is_random=True, figsize=(16, 16)): plt.figure(figsize=figsize) w = int(n_images ** .5) h = math.ceil(n_images / w) image_names = path.ls() for i in range(n_images): image_name = random.choice(image_names) if is_random else image_name[i]; img = cv2.imread(str(image_name)) plt.subplot(h, w, i + 1) plt.imshow(img) plt.xticks([]) plt.yticks([]) plt.show() . from google.colab import drive drive.mount(&#39;/content/gdrive&#39;, force_remount=True) . Mounted at /content/gdrive . class BaseConfig(object): SEED = 101 PROJECT_PATH = Path(&#39;/content/gdrive/MyDrive/1_AUSTIN CHEN/Data Scientist/Datasets/cassava-leaf-disease-classification&#39;) TRAIN_DF = PROJECT_PATH/&#39;train.csv&#39; TRAIN_IMG_PATH = PROJECT_PATH/&#39;train_images/&#39; TEST_IMG_PATH = PROJECT_PATH/&#39;test_images/&#39; CLASS_MAP = PROJECT_PATH/&#39;label_num_to_disease_map.json&#39; . df = pd.read_csv(BaseConfig.TRAIN_DF) df.head() . image_id label . 0 1000015157.jpg | 0 | . 1 1000201771.jpg | 3 | . 2 100042118.jpg | 1 | . 3 1000723321.jpg | 1 | . 4 1000812911.jpg | 3 | . assert(len(df.image_id) == len(df.image_id.unique()), &quot;NOT ALL ID UNIQUE&quot;) . with open(str(BaseConfig.CLASS_MAP)) as file: id2label = json.loads(file.read()) . id2label . {&#39;0&#39;: &#39;Cassava Bacterial Blight (CBB)&#39;, &#39;1&#39;: &#39;Cassava Brown Streak Disease (CBSD)&#39;, &#39;2&#39;: &#39;Cassava Green Mottle (CGM)&#39;, &#39;3&#39;: &#39;Cassava Mosaic Disease (CMD)&#39;, &#39;4&#39;: &#39;Healthy&#39;} . temp_df = df.copy() temp_df[list(id2label.values())] = pd.get_dummies(temp_df[&quot;label&quot;]) . fig = go.Figure( data=[go.Pie(labels=temp_df.columns[2:], values=temp_df.iloc[:,2:].sum().values)]) fig.show() . . . visualize(BaseConfig.TRAIN_IMG_PATH, 16, is_random=True) . Augmentation . The albumentation is primarily used for resizing and normalization. . def albu_transforms_train(data_resize): return A.Compose([ A.ToFloat(), A.Resize(data_resize, data_resize), ], p=1.) # For Validation def albu_transforms_valid(data_resize): return A.Compose([ A.ToFloat(), A.Resize(data_resize, data_resize), ], p=1.) . def CutMix(image, label, DIM, PROBABILITY = 1.0): # input image - is a batch of images of size [n,dim,dim,3] not a single image of [dim,dim,3] # output - a batch of images with cutmix applied CLASSES = 5 imgs = []; labs = [] for j in range(len(image)): # DO CUTMIX WITH PROBABILITY DEFINED ABOVE P = tf.cast( tf.random.uniform([],0,1)&lt;=PROBABILITY, tf.int32) # CHOOSE RANDOM IMAGE TO CUTMIX WITH k = tf.cast( tf.random.uniform([],0,len(image)),tf.int32) # CHOOSE RANDOM LOCATION x = tf.cast( tf.random.uniform([],0,DIM),tf.int32) y = tf.cast( tf.random.uniform([],0,DIM),tf.int32) b = tf.random.uniform([],0,1) # this is beta dist with alpha=1.0 WIDTH = tf.cast( DIM * tf.math.sqrt(1-b),tf.int32) * P ya = tf.math.maximum(0,y-WIDTH//2) yb = tf.math.minimum(DIM,y+WIDTH//2) xa = tf.math.maximum(0,x-WIDTH//2) xb = tf.math.minimum(DIM,x+WIDTH//2) # MAKE CUTMIX IMAGE one = image[j,ya:yb,0:xa,:] two = image[k,ya:yb,xa:xb,:] three = image[j,ya:yb,xb:DIM,:] middle = tf.concat([one,two,three],axis=1) img = tf.concat([image[j,0:ya,:,:],middle,image[j,yb:DIM,:,:]],axis=0) imgs.append(img) # MAKE CUTMIX LABEL a = tf.cast(WIDTH*WIDTH/DIM/DIM,tf.float32) labs.append((1-a)*label[j] + a*label[k]) # RESHAPE HACK SO TPU COMPILER KNOWS SHAPE OF OUTPUT TENSOR (maybe use Python typing instead?) image2 = tf.reshape(tf.stack(imgs),(len(image),DIM,DIM,3)) label2 = tf.reshape(tf.stack(labs),(len(image),CLASSES)) return image2,label2 . def MixUp(image, label, DIM, PROBABILITY = 1.0): # input image - is a batch of images of size [n,dim,dim,3] not a single image of [dim,dim,3] # output - a batch of images with mixup applied CLASSES = 5 imgs = []; labs = [] for j in range(len(image)): # DO MIXUP WITH PROBABILITY DEFINED ABOVE P = tf.cast( tf.random.uniform([],0,1)&lt;=PROBABILITY, tf.float32) # CHOOSE RANDOM k = tf.cast( tf.random.uniform([],0,len(image)),tf.int32) a = tf.random.uniform([],0,1)*P # this is beta dist with alpha=1.0 # MAKE MIXUP IMAGE img1 = image[j,] img2 = image[k,] imgs.append((1-a)*img1 + a*img2) # MAKE CUTMIX LABEL labs.append((1-a)*label[j] + a*label[k]) # RESHAPE HACK SO TPU COMPILER KNOWS SHAPE OF OUTPUT TENSOR (maybe use Python typing instead?) image2 = tf.reshape(tf.stack(imgs),(len(image),DIM,DIM,3)) label2 = tf.reshape(tf.stack(labs),(len(image),CLASSES)) return image2,label2 . Custom Data Generator . import pdb . class CassavaGenerator(tf.keras.utils.Sequence): def __init__(self, path, data, bs, dim, shuffle=True, tfm=None, use_mixup=False, use_cutmix=False, use_fmix=False): self.path = path self.data = data self.bs = bs self.dim = dim self.shuffle = shuffle self.augment = tfm self.use_mixup = use_mixup self.use_cutmix = use_cutmix self.use_fmix = use_fmix self.list_idx = self.data.index.values self.label = pd.get_dummies(self.data[&#39;label&#39;], columns=[&#39;label&#39;]) self.on_epoch_end() def __len__(self): return int(np.ceil(float(len(self.data)) / float(self.bs))) def __getitem__(self, index): #start = index * self.bs #end = (index+1) * self.bs #batch_ids = self.indices[start:end] batch_idx = self.indices[index*self.bs:(index+1)*self.bs] idx = [self.list_idx[k] for k in batch_idx] xs = np.empty((self.bs, *self.dim)) ys = np.empty((self.bs, 5), dtype=np.float32) for i,k in enumerate(idx): #pdb.set_trace() image = cv2.imread(f&quot;{self.path}/{self.data[&#39;image_id&#39;][k]}&quot;) image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) augmented = self.augment(image=image) image = augmented[&#39;image&#39;] xs[i, :, :, :] = image ys[i, :] = self.label.loc[k, :].values if self.use_cutmix: xs, ys = CutMix(xs, ys, self.dim[0]) if self.use_mixup: xs, ys = MixUp(xs, ys, self.dim[0]) if self.use_fmix: xs, ys = FMix(xs, ys, self.dim[0]) return xs, ys def on_epoch_end(self): self.indices = np.arange(len(self.list_idx)) if self.shuffle: np.random.shuffle(self.indices) . def plot_imgs(dataset_show, iters): rcParams[&#39;figure.figsize&#39;] = 20,10 for i in range(iters): f, ax = plt.subplots(1,5) for p in range(5): idx = np.random.randint(0, len(dataset_show)) img, label = dataset_show[idx] ax[p].grid(False) ax[p].imshow(img[0]) ax[p].set_title(idx) plt.show() . dg = CassavaGenerator(BaseConfig.TRAIN_IMG_PATH, df, 20, (128,128,3), shuffle=True, use_mixup=False, use_cutmix=True, use_fmix=False, tfm=albu_transforms_train(128)) . dg[0] . TypeError Traceback (most recent call last) &lt;ipython-input-84-89a6c6208e75&gt; in &lt;module&gt;() -&gt; 1 dg[0] &lt;ipython-input-82-9569360faa96&gt; in __getitem__(self, index) 37 image = augmented[&#39;image&#39;] 38 &gt; 39 xs[i, :, :, :] = image 40 ys[i, :] = self.label.loc[k, :].values 41 TypeError: &#39;tensorflow.python.framework.ops.EagerTensor&#39; object does not support item assignment . Moving to the next 1% improvement . Fix the TypeError: &#39;tensorflow.python.framework.ops.EagerTensor&#39; object does not support item assignment error and figure why there is a difference between Kaggle and Colab. |",
            "url": "https://austinyhc.github.io/blog/plant/disease/classification/eda/2020/12/09/Cassava_Leaf_Disease_Classification_EDA.html",
            "relUrl": "/plant/disease/classification/eda/2020/12/09/Cassava_Leaf_Disease_Classification_EDA.html",
            "date": " • Dec 9, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Cassava Leaf Disease Classification",
            "content": "This is an introductory notebook contains creating a baseline model using Tensor Processing Units (TPUs) and begins making submissions to the Cassava Leaf Disease Classification competition. . TPUs with TensorFlow . We&#39;ll be using TensorFlow and Keras to build our computer vision model, and using TPUs to both train our model and make predictions. . References . This notebook was built using the following amazing resources created by Kagglers: . Learn With Me: Getting Started with Tensor Processing Units (TPUs) | Martin Gorner: Getting Started With 100 Flowers on TPU | Amy Jang: TensorFlow + Transfer Learning: Melanoma | Phil Culliton: [A Simple TF 2.1 Notebook](https://www.kaggle.com/philculliton/a-simple-tf-2-1-notebook | . Dependencies . import math, os, re, warnings, random import numpy as np import pandas as pd import seaborn as sns from functools import partial from matplotlib import pyplot as plt from sklearn.utils import class_weight from sklearn.model_selection import KFold, train_test_split from sklearn.metrics import classification_report, confusion_matrix, accuracy_score from tensorflow import keras import tensorflow as tf #import efficientnet.tfkeras as efn def seed_everything(seed=0): random.seed(seed) np.random.seed(seed) tf.random.set_seed(seed) os.environ[&#39;PYTHONHASHSEED&#39;] = str(seed) os.environ[&#39;TF_DETERMINISTIC_OPS&#39;] = &#39;1&#39; seed = 0 seed_everything(seed) warnings.filterwarnings(&#39;ignore&#39;) . Hardware configuration . Download data from Kaggle . Set up variables . AUTOTUNE = tf.data.experimental.AUTOTUNE GCS_PATH = &#39;gs://kds-041bbb000630fa3aaebc67ffddc6dd4b536981c56338d1734b8511fe&#39; BATCH_SIZE = 16 * strategy.num_replicas_in_sync IMAGE_SIZE = [512, 512] CLASSES = [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;] EPOCHS = 25 . Load data . The data we&#39;re working with have been formatted into TFRecords, which are a format for storing a sequence of binary records. TFRecords work really well with TPUs, and allow us to send a small number of large files across the TPU for processing. . If you&#39;d like to learn more about TFRecords and maybe even try creating them yourself, check out this TFRecords Basics notebook and corresponding video from Kaggle Data Scientist Ryan Holbrook. . Because our data consists of training and test images only, we&#39;re going to split our training data into training and validation data using the train_test_split() function. . Decode the data . In the code chunk below we&#39;ll set up a series of functions that allow us to convert our images into tensors so that we can utilize them in our model. We&#39;ll also normalize our data. Our images are using a &quot;Red, Blue, Green(RGB)&quot; scale that has a range of [0,255], and by normalizing it we&#39;ll set each pixel&#39;s value to a number in the range of [0, 1]. . def decode_image(image): image = tf.image.decode_jpeg(image, channels=3) image = tf.cast(image, tf.float32) / 255.0 image = tf.reshape(image, [*IMAGE_SIZE, 3]) return image . def read_tfrecord(example, labeled): tfrecord_format = { &quot;image&quot;: tf.io.FixedLenFeature([], tf.string), &quot;target&quot;: tf.io.FixedLenFeature([], tf.int64) } if labeled else { &quot;image&quot;: tf.io.FixedLenFeature([], tf.string), &quot;image_name&quot;: tf.io.FixedLenFeature([], tf.string) } example = tf.io.parse_single_example(example, tfrecord_format) image = decode_image(example[&#39;image&#39;]) if labeled: label = tf.cast(example[&#39;target&#39;], tf.int32) return image, label idnum = example[&#39;image_name&#39;] return image, idnum . We&#39;ll use the following function to load our dataset. One of the advantage of a TPU is that we can run multiple files across the TPU at once, and this accounts for the speed advantages of using a TPU. To capitalize on that, we want to make sure that we&#39;re using data as soon as it streams in, rather than creating a data streaming bottleneck. . def load_dataset(filenames, labeled=True, ordered=False): ignore_order = tf.data.Options() if not ordered: ignore_order.experimental_deterministic = False # disable order, increase speed dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads=AUTOTUNE) # automatically interleaves reads from multiple files dataset = dataset.with_options(ignore_order) # uses data as soon as it streams in, rather than in its original order dataset = dataset.map(partial(read_tfrecord, labeled=labeled), num_parallel_calls=AUTOTUNE) return dataset . A note of using train_test_split() . While i used train_test_split() to create both a training and validation dataset, consider exploring cross validation instead. . TRAINING_FILENAMES, VALID_FILENAMES = train_test_split( tf.io.gfile.glob(GCS_PATH + &#39;/train_tfrecords/ld_train*.tfrec&#39;), test_size=0.35, random_state=5 ) TEST_FILENAMES = tf.io.gfile.glob(GCS_PATH + &#39;/test_tfrecords/ld_test*.tfrec&#39;) . Adding in augmentations . def data_augment(image, label): # Thanks to the dataset.prefetch(AUTO) statement in the following function this happens essentially for free on TPU. # Data pipeline code is executed on the &quot;CPU&quot; part of the TPU while the TPU itself is computing gradients. image = tf.image.random_flip_left_right(image) return image, label . Define data loading methods . The following functions will be used to load our training, validation, and test datasets, as well as print out the number of images in each dataset. . def get_training_dataset(): dataset = load_dataset(TRAINING_FILENAMES, labeled=True) dataset = dataset.map(data_augment, num_parallel_calls=AUTOTUNE) dataset = dataset.repeat() dataset = dataset.shuffle(2048) dataset = dataset.batch(BATCH_SIZE) dataset = dataset.prefetch(AUTOTUNE) return dataset . def get_validation_dataset(ordered=False): dataset = load_dataset(VALID_FILENAMES, labeled=True, ordered=ordered) dataset = dataset.batch(BATCH_SIZE) dataset = dataset.cache() dataset = dataset.prefetch(AUTOTUNE) return dataset . def get_test_dataset(ordered=False): dataset = load_dataset(TEST_FILENAMES, labeled=False, ordered=ordered) dataset = dataset.batch(BATCH_SIZE) dataset = dataset.prefetch(AUTOTUNE) return dataset . def count_data_items(filenames): n = [int(re.compile(r&quot;-([0-9]*) .&quot;).search(filename).group(1)) for filename in filenames] return np.sum(n) . NUM_TRAINING_IMAGES = count_data_items(TRAINING_FILENAMES) NUM_VALIDATION_IMAGES = count_data_items(VALID_FILENAMES) NUM_TEST_IMAGES = count_data_items(TEST_FILENAMES) print(&#39;Dataset: {} training images, {} validation images, {} (unlabeled) test images&#39;.format( NUM_TRAINING_IMAGES, NUM_VALIDATION_IMAGES, NUM_TEST_IMAGES)) . Dataset: 13380 training images, 8017 validation images, 1 (unlabeled) test images . Brief EDA . print(&quot;Training data shapes:&quot;) for image, label in get_training_dataset().take(3): print(image.numpy().shape, label.numpy().shape) print(&quot;Training data label examples:&quot;, label.numpy()) print(&quot;Validation data shapes:&quot;) for image, label in get_validation_dataset().take(3): print(image.numpy().shape, label.numpy().shape) print(&quot;Validation data label examples:&quot;, label.numpy()) print(&quot;Test data shapes:&quot;) for image, idnum in get_test_dataset().take(3): print(image.numpy().shape, idnum.numpy().shape) print(&quot;Test data IDs:&quot;, idnum.numpy().astype(&#39;U&#39;)) # U=unicode string . Training data shapes: (128, 512, 512, 3) (128,) (128, 512, 512, 3) (128,) (128, 512, 512, 3) (128,) Training data label examples: [3 3 3 0 1 1 3 3 0 3 2 1 3 1 4 4 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 1 2 3 3 3 2 3 3 3 3 3 1 3 4 3 3 3 3 3 0 2 2 3 3 0 0 3 3 3 3 4 3 3 3 3 1 0 3 3 1 3 4 2 3 3 4 3 1 2 3 3 4 3 2 3 1 3 3 3 2 1 2 3 3 4 2 3 3 3 3 3 3 2 3 1 2 4 1 3 3 3 4 3 2 3 2 2 1 3 3 3 1 3 3 3 3] Validation data shapes: (128, 512, 512, 3) (128,) (128, 512, 512, 3) (128,) (128, 512, 512, 3) (128,) Validation data label examples: [3 3 3 1 3 3 3 3 4 0 4 3 0 2 4 3 3 3 3 1 3 3 2 3 3 3 1 2 3 3 1 3 0 3 3 1 3 4 3 3 3 3 4 4 2 3 2 2 3 3 2 3 3 1 1 3 4 3 4 3 4 3 3 3 3 3 2 1 0 4 3 3 3 3 3 0 0 2 3 3 3 2 3 3 1 3 3 3 3 3 4 3 0 3 3 2 1 3 3 3 4 4 4 3 4 3 3 3 2 4 1 3 4 3 4 3 2 0 1 3 3 2 2 3 3 2 3 0] Test data shapes: (1, 512, 512, 3) (1,) Test data IDs: [&#39;2216849948.jpg&#39;] . np.set_printoptions(threshold=15, linewidth=80) def batch_to_numpy_images_and_labels(data): images, labels = data numpy_images = images.numpy() numpy_labels = labels.numpy() if numpy_labels.dtype == object: # binary string in this case, these are image ID strings numpy_labels = [None for _ in enumerate(numpy_images)] # If no labels, only image IDs, return None for labels (this is the case for test data) return numpy_images, numpy_labels def title_from_label_and_target(label, correct_label): if correct_label is None: return CLASSES[label], True correct = (label == correct_label) return &quot;{} [{}{}{}]&quot;.format(CLASSES[label], &#39;OK&#39; if correct else &#39;NO&#39;, u&quot; u2192&quot; if not correct else &#39;&#39;, CLASSES[correct_label] if not correct else &#39;&#39;), correct def display_one_plant(image, title, subplot, red=False, titlesize=16): plt.subplot(*subplot) plt.axis(&#39;off&#39;) plt.imshow(image) if len(title) &gt; 0: plt.title(title, fontsize=int(titlesize) if not red else int(titlesize/1.2), color=&#39;red&#39; if red else &#39;black&#39;, fontdict={&#39;verticalalignment&#39;:&#39;center&#39;}, pad=int(titlesize/1.5)) return (subplot[0], subplot[1], subplot[2]+1) def display_batch_of_images(databatch, predictions=None): &quot;&quot;&quot;This will work with: display_batch_of_images(images) display_batch_of_images(images, predictions) display_batch_of_images((images, labels)) display_batch_of_images((images, labels), predictions) &quot;&quot;&quot; # data images, labels = batch_to_numpy_images_and_labels(databatch) if labels is None: labels = [None for _ in enumerate(images)] # auto-squaring: this will drop data that does not fit into square or square-ish rectangle rows = int(math.sqrt(len(images))) cols = len(images)//rows # size and spacing FIGSIZE = 13.0 SPACING = 0.1 subplot=(rows,cols,1) if rows &lt; cols: plt.figure(figsize=(FIGSIZE,FIGSIZE/cols*rows)) else: plt.figure(figsize=(FIGSIZE/rows*cols,FIGSIZE)) # display for i, (image, label) in enumerate(zip(images[:rows*cols], labels[:rows*cols])): title = &#39;&#39; if label is None else CLASSES[label] correct = True if predictions is not None: title, correct = title_from_label_and_target(predictions[i], label) dynamic_titlesize = FIGSIZE*SPACING/max(rows,cols)*40+3 # magic formula tested to work from 1x1 to 10x10 images subplot = display_one_plant(image, title, subplot, not correct, titlesize=dynamic_titlesize) #layout plt.tight_layout() if label is None and predictions is None: plt.subplots_adjust(wspace=0, hspace=0) else: plt.subplots_adjust(wspace=SPACING, hspace=SPACING) plt.show() . training_dataset = get_training_dataset() training_dataset = training_dataset.unbatch().batch(20) train_batch = iter(training_dataset) . display_batch_of_images(next(train_batch)) . validation_dataset = get_validation_dataset() validation_dataset = validation_dataset.unbatch().batch(20) valid_batch = iter(validation_dataset) . display_batch_of_images(next(valid_batch)) . testing_dataset = get_test_dataset() testing_dataset = testing_dataset.unbatch().batch(20) test_batch = iter(testing_dataset) . display_batch_of_images(next(test_batch)) . Building the model . Learning rate schedule . We learned about learning rates in the Intro to Deep Learning: Stochastic Gradient Descent lesson, and here I&#39;ve created a learning rate schedule mostly using the defaults in the Keras Exponential Decay Learning Rate Scheduler documentation (I did change the initial_learning_rate. You can adjust the learning rate scheduler below, and read more about the other types of schedulers available to you in the Keras learning rate schedules API. . print(&quot;Tensorflow version &quot; + tf.__version__) . Tensorflow version 2.3.0 . lr_scheduler = keras.optimizers.schedules.ExponentialDecay( initial_learning_rate=1e-5, decay_steps=10000, decay_rate=0.9) . Building our model . In order to ensure that our model is trained on the TPU, we build it using with strategy.scope(). . This model was built using transfer learning, meaning that we have a pre-trained model (ResNet50) as our base model and then the customizable model built using tf.keras.Sequential. If you&#39;re new to transfer learning I recommend setting base_model.trainable to False, but do encourage you to change which base model you&#39;re using (more options are available in the tf.keras.applications Module documentation) as well iterate on the custom model. . Note that we&#39;re using sparse_categorical_crossentropy as our loss function, because we did not one-hot encode our labels. . with strategy.scope(): img_adjust_layer = tf.keras.layers.Lambda(tf.keras.applications.resnet50.preprocess_input, input_shape=[*IMAGE_SIZE, 3]) base_model = tf.keras.applications.ResNet50(weights=&#39;imagenet&#39;, include_top=False) base_model.trainable = False model = tf.keras.Sequential([ tf.keras.layers.BatchNormalization(renorm=True), img_adjust_layer, base_model, tf.keras.layers.GlobalAveragePooling2D(), tf.keras.layers.Dense(8, activation=&#39;relu&#39;), #tf.keras.layers.BatchNormalization(renorm=True), tf.keras.layers.Dense(len(CLASSES), activation=&#39;softmax&#39;) ]) model.compile( optimizer=tf.keras.optimizers.Adam(learning_rate=lr_scheduler, epsilon=0.001), loss=&#39;sparse_categorical_crossentropy&#39;, metrics=[&#39;sparse_categorical_accuracy&#39;]) . Train the model . As our model is training you&#39;ll see a printout for each epoch, and can also monitor TPU usage by clicking on the TPU metrics in the toolbar at the top right of your notebook. . train_dataset = get_training_dataset() valid_dataset = get_validation_dataset() . STEPS_PER_EPOCH = NUM_TRAINING_IMAGES // BATCH_SIZE VALID_STEPS = NUM_VALIDATION_IMAGES // BATCH_SIZE history = model.fit(train_dataset, steps_per_epoch=STEPS_PER_EPOCH, epochs=EPOCHS, validation_data=valid_dataset, validation_steps=VALID_STEPS) . With model.summary() we&#39;ll see a printout of each of our layers, their corresponding shape, as well as the associated number of parameters. Notice that at the bottom of the printout we&#39;ll see information on the total parameters, trainable parameters, and non-trainable parameters. Because we&#39;re using a pre-trained model, we expect there to be a large number of non-trainable parameters (because the weights have already been assigned in the pre-trained model). . model.summary() . Evaluating our model . The first chunk of code is provided to show you where the variables in the second chunk of code came from. As you can see, there&#39;s a lot of room for improvement in this model, but because we&#39;re using TPUs and have a relatively short training time, we&#39;re able to iterate on our model fairly rapidly. . print(history.history.keys()) . history_frame = pd.DataFrame(history.history) history_frame.loc[:, [&#39;loss&#39;, &#39;val_loss&#39;]].plot() history_frame.loc[:, [&#39;sparse_categorical_accuracy&#39;, &#39;val_sparse_categorical_accuracy&#39;]].plot(); . Making predictions . Now that we&#39;ve trained our model we can use it to make predictions. . def to_float32(image, label): return tf.cast(image, tf.float32), label . test_ds = get_test_dataset(ordered=True) test_ds = test_ds.map(to_float32) print(&#39;Computing predictions...&#39;) test_images_ds = testing_dataset test_images_ds = test_ds.map(lambda image, idnum: image) probabilities = model.predict(test_images_ds) predictions = np.argmax(probabilities, axis=-1) print(predictions) . Creating a submission file . Now that we&#39;ve trained a model and made predictions we&#39;re ready to submit to the competition! You can run the following code below to get your submission file. . print(&#39;Generating submission.csv file...&#39;) test_ids_ds = test_ds.map(lambda image, idnum: idnum).unbatch() test_ids = next(iter(test_ids_ds.batch(NUM_TEST_IMAGES))).numpy().astype(&#39;U&#39;) # all in one batch np.savetxt(&#39;submission.csv&#39;, np.rec.fromarrays([test_ids, predictions]), fmt=[&#39;%s&#39;, &#39;%d&#39;], delimiter=&#39;,&#39;, header=&#39;id,label&#39;, comments=&#39;&#39;) !head submission.csv . Be aware that because this is a code competition with a hidden test set, internet and TPUs cannot be enabled on your submission notebook. Therefore TPUs will only be available for training models. For a walk-through on how to train on TPUs and run inference/submit on GPUs, see our TPU Docs. .",
            "url": "https://austinyhc.github.io/blog/jupyter/2020/12/09/Cassava_Leaf_Disease_Classification.html",
            "relUrl": "/jupyter/2020/12/09/Cassava_Leaf_Disease_Classification.html",
            "date": " • Dec 9, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://austinyhc.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://austinyhc.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am Austin; after years plunging into Smartphone Industry and IC Design, I have found data science is crucial in every aspect possible. Thanks to Jeremy Howard, the founder of Fast.ai, he re-enlightens my passion for Machine Learning, especially Deep Learning and Transfer Learning. I have freelanced with different organizations and continuously strive to apply DL to any project, team, or goal. Hope to meet a ton of you in the sphere of AI and to contribute as best as I can to your community. .",
          "url": "https://austinyhc.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://austinyhc.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}